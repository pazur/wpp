from songbook.export import songtree


# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class LyricsScanner(runtime.Scanner):
    patterns = [
        ('EMPTY', re.compile('\n')),
        ('VERSE', re.compile('verse text (\\$chords)?\n')),
        ('PIPE', re.compile('verse text | (\\$chords)?\n')),
        ('PIPETEXT', re.compile('verse text | txt (\\$chords)?\n')),
        ('CHORUS_OP', re.compile('<chorus>')),
        ('CHORUS_CL', re.compile('</chorus>')),
        ('EOF', re.compile('$')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{},str,*args,**kw)

class Lyrics(runtime.Parser):
    Context = runtime.Context
    def entry(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'entry', [])
        lyrics = self.lyrics(_context)
        EOF = self._scan('EOF', context=_context)
        return songtree.Lyrics(lyrics)

    def lyrics(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'lyrics', [])
        _token = self._peek('EOF', 'CHORUS_OP', 'VERSE', 'PIPETEXT', 'PIPE', context=_context)
        if _token not in ['EOF', 'CHORUS_OP']:
            stanza = self.stanza(_context)
            lyrics_sep = self.lyrics_sep(_context)
            return [stanza] + lyrics_sep
        elif _token == 'CHORUS_OP':
            chorus = self.chorus(_context)
            maybe_empty = self.maybe_empty(_context)
            lyrics = self.lyrics(_context)
            return [chorus] + lyrics
        else: # == 'EOF'
            return []

    def lyrics_sep(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'lyrics_sep', [])
        _token = self._peek('EMPTY', 'CHORUS_OP', 'EOF', context=_context)
        if _token == 'EMPTY':
            EMPTY = self._scan('EMPTY', context=_context)
            lyrics = self.lyrics(_context)
            return lyrics
        elif _token == 'CHORUS_OP':
            chorus = self.chorus(_context)
            maybe_empty = self.maybe_empty(_context)
            lyrics = self.lyrics(_context)
            return [chorus] + lyrics
        else: # == 'EOF'
            return []

    def maybe_empty(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'maybe_empty', [])
        _token = self._peek( context=_context)
        if _token == 'EMPTY':
            EMPTY = self._scan('EMPTY', context=_context)
        else:
            pass

    def chorus(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'chorus', [])
        CHORUS_OP = self._scan('CHORUS_OP', context=_context)
        maybe_empty = self.maybe_empty(_context)
        stanza_lst = self.stanza_lst(_context)
        CHORUS_CL = self._scan('CHORUS_CL', context=_context)
        return songtree.Chorus(stanza_lst)

    def stanza_lst(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'stanza_lst', [])
        _token = self._peek('CHORUS_CL', 'VERSE', 'PIPETEXT', 'PIPE', context=_context)
        if _token != 'CHORUS_CL':
            stanza = self.stanza(_context)
            stanza_lst_sep = self.stanza_lst_sep(_context)
            return [stanza] + stanza_lst_sep
        else: # == 'CHORUS_CL'
            return []

    def stanza_lst_sep(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'stanza_lst_sep', [])
        _token = self._peek('EMPTY', 'CHORUS_CL', context=_context)
        if _token == 'EMPTY':
            EMPTY = self._scan('EMPTY', context=_context)
            stanza_lst = self.stanza_lst(_context)
            return stanza_lst
        else: # == 'CHORUS_CL'
            return []

    def stanza(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'stanza', [])
        group = self.group(_context)
        group_lst = self.group_lst(_context)
        return songtree.Stanza([group] + group_lst)

    def group_lst(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'group_lst', [])
        _token = self._peek( context=_context)
        if _token not in ['EMPTY', 'CHORUS_OP', 'EOF', 'CHORUS_CL']:
            group = self.group(_context)
            group_lst = self.group_lst(_context)
            return [group] + group_lst
        else: # in ['EMPTY', 'CHORUS_OP', 'EOF', 'CHORUS_CL']
            return []

    def group(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'group', [])
        _token = self._peek('VERSE', 'PIPETEXT', 'PIPE', context=_context)
        if _token == 'VERSE':
            VERSE = self._scan('VERSE', context=_context)
            return VERSE
        else: # in ['PIPETEXT', 'PIPE']
            pipe_lst = self.pipe_lst(_context)
            PIPETEXT = self._scan('PIPETEXT', context=_context)
            return songtree.Group(pipe_lst + [PIPETEXT])

    def pipe_lst(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'pipe_lst', [])
        _token = self._peek('PIPE', 'PIPETEXT', context=_context)
        if _token == 'PIPE':
            PIPE = self._scan('PIPE', context=_context)
            pipe_lst = self.pipe_lst(_context)
            return [PIPE] + pipe_lst
        else: # == 'PIPETEXT'
            return []


def parse(rule, text):
    P = Lyrics(LyricsScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
